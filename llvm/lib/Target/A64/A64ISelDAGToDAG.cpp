//===-- A64ISelDAGToDAG.cpp - A dag to dag inst selector for A64 ---------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the A64 target.
//
//===----------------------------------------------------------------------===//

#include "A64.h"
#include "A64InstrInfo.h"
#include "A64TargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "MCTargetDesc/A64AddressingModes.h"

using namespace llvm;

#define DEBUG_TYPE "a64-isel"

//===--------------------------------------------------------------------===//
/// A64DAGToDAGISel - A64 specific code to select A64 machine
/// instructions for SelectionDAG operations.
///
namespace {

class A64DAGToDAGISel : public SelectionDAGISel {

public:
  explicit A64DAGToDAGISel(A64TargetMachine &tm, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(tm, OptLevel) {}

  void Select(SDNode *Node) override;

  StringRef getPassName() const override {
    return "A64 DAG -> DAG Pattern Instruction Selection";
  }

  bool SelectArithShiftedRegister(SDValue N, SDValue &Reg, SDValue &Shift) {
    return SelectShiftedRegister(N, false, Reg, Shift);
  }
  bool SelectLogicalShiftedRegister(SDValue N, SDValue &Reg, SDValue &Shift) {
    return SelectShiftedRegister(N, true, Reg, Shift);
  }
  bool SelectAddrModeIndexed64(SDValue N, SDValue &Base, SDValue &OffImm) {
    return SelectAddrModeIndexed(N, 8, Base, OffImm);
  }
  bool SelectArithImmed(SDValue N, SDValue &Val, SDValue &Shift);

  // Autogenerated from target description
#include "A64GenDAGISel.inc"

private:
  bool SelectShiftedRegister(SDValue N, bool AllowROR, SDValue &Reg,
                             SDValue &Shift);
  bool SelectAddrModeIndexed(SDValue N, unsigned Size, SDValue &Base,
                             SDValue &OffImm);
};
} // End anonymous namespace

void A64DAGToDAGISel::Select(SDNode *Node) {
  // Forward to generated function.
  SelectCode(Node);
}

/// SelectArithImmed - Select an immediate value that can be represented as
/// a 12-bit value shifted left by either 0 or 12.  If so, return true with
/// Val set to the 12-bit value and Shift set to the shifter operand.
bool A64DAGToDAGISel::SelectArithImmed(SDValue N, SDValue &Val,
                                       SDValue &Shift) {
  // This function is called from the addsub_shifted_imm ComplexPattern,
  // which lists [imm] as the list of opcode it's interested in, however
  // we still need to check whether the operand is actually an immediate
  // here because the ComplexPattern opcode list is only used in
  // root-level opcode matching.
  if (!isa<ConstantSDNode>(N.getNode()))
    return false;

  uint64_t Immed = cast<ConstantSDNode>(N.getNode())->getZExtValue();
  unsigned ShiftAmt;

  if (Immed >> 12 == 0) {
    ShiftAmt = 0;
  } else if ((Immed & 0xfff) == 0 && Immed >> 24 == 0) {
    ShiftAmt = 12;
    Immed = Immed >> 12;
  } else
    return false;

  unsigned ShVal = A64_AM::getShifterImm(A64_AM::LSL, ShiftAmt);
  SDLoc dl(N);
  Val = CurDAG->getTargetConstant(Immed, dl, MVT::i32);
  Shift = CurDAG->getTargetConstant(ShVal, dl, MVT::i32);
  return true;
}

/// getShiftTypeForNode - Translate a shift node to the corresponding
/// ShiftType value.
static A64_AM::ShiftExtendType getShiftTypeForNode(SDValue N) {
  switch (N.getOpcode()) {
  default:
    return A64_AM::InvalidShiftExtend;
  case ISD::SHL:
    return A64_AM::LSL;
  case ISD::SRL:
    return A64_AM::LSR;
  case ISD::SRA:
    return A64_AM::ASR;
  case ISD::ROTR:
    return A64_AM::ROR;
  }
}

bool A64DAGToDAGISel::SelectShiftedRegister(SDValue N, bool AllowROR,
                                            SDValue &Reg, SDValue &Shift) {
  A64_AM::ShiftExtendType ShType = getShiftTypeForNode(N);
  if (ShType == A64_AM::InvalidShiftExtend)
    return false;
  if (!AllowROR && ShType == A64_AM::ROR)
    return false;

  if (ConstantSDNode *RHS = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
    unsigned BitSize = N.getValueSizeInBits();
    unsigned Val = RHS->getZExtValue() & (BitSize - 1);
    unsigned ShVal = A64_AM::getShifterImm(ShType, Val);

    Reg = N.getOperand(0);
    Shift = CurDAG->getTargetConstant(ShVal, SDLoc(N), MVT::i32);
    return true; // isWorthFolding(N);
  }

  return false;
}

/// If there's a use of this ADDlow that's not itself a load/store then we'll
/// need to create a real ADD instruction from it anyway and there's no point in
/// folding it into the mem op. Theoretically, it shouldn't matter, but there's
/// a single pseudo-instruction for an ADRP/ADD pair so over-aggressive folding
/// leads to duplicated ADRP instructions.
static bool isWorthFoldingADDlow(SDValue N) {
  for (auto Use : N->uses()) {
    if (Use->getOpcode() != ISD::LOAD && Use->getOpcode() != ISD::STORE)
      return false;
  }

  return true;
}

bool A64DAGToDAGISel::SelectAddrModeIndexed(SDValue N, unsigned Size,
                                            SDValue &Base, SDValue &OffImm) {
  SDLoc dl(N);
  const DataLayout &DL = CurDAG->getDataLayout();
  const TargetLowering *TLI = getTargetLowering();
  if (N.getOpcode() == ISD::FrameIndex) {
    int FI = cast<FrameIndexSDNode>(N)->getIndex();
    Base = CurDAG->getTargetFrameIndex(FI, TLI->getPointerTy(DL));
    OffImm = CurDAG->getTargetConstant(0, dl, MVT::i64);
    return true;
  }

  if (N.getOpcode() == A64ISD::ADDlow && isWorthFoldingADDlow(N)) {
    GlobalAddressSDNode *GAN =
        dyn_cast<GlobalAddressSDNode>(N.getOperand(1).getNode());
    Base = N.getOperand(0);
    OffImm = N.getOperand(1);
    if (!GAN)
      return true;

    if (GAN->getOffset() % Size == 0 &&
        GAN->getGlobal()->getPointerAlignment(DL) >= Size)
      return true;
  }

  if (CurDAG->isBaseWithConstantOffset(N)) {
    if (ConstantSDNode *RHS = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
      int64_t RHSC = (int64_t)RHS->getZExtValue();
      unsigned Scale = Log2_32(Size);
      if ((RHSC & (Size - 1)) == 0 && RHSC >= 0 && RHSC < (0x1000 << Scale)) {
        Base = N.getOperand(0);
        if (Base.getOpcode() == ISD::FrameIndex) {
          int FI = cast<FrameIndexSDNode>(Base)->getIndex();
          Base = CurDAG->getTargetFrameIndex(FI, TLI->getPointerTy(DL));
        }
        OffImm = CurDAG->getTargetConstant(RHSC >> Scale, dl, MVT::i64);
        return true;
      }
    }
  }

  // Base only. The address will be materialized into a register before
  // the memory is accessed.
  //    add x0, Xbase, #offset
  //    ldr x0, [x0]
  Base = N;
  OffImm = CurDAG->getTargetConstant(0, dl, MVT::i64);
  return true;
}

/// createA64ISelDag - This pass converts a legalized DAG into a
/// A64-specific DAG, ready for instruction scheduling.
FunctionPass *llvm::createA64ISelDag(A64TargetMachine &TM,
                                     CodeGenOpt::Level OptLevel) {
  return new A64DAGToDAGISel(TM, OptLevel);
}
