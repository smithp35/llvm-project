//===- A64Disassembler.cpp - Disassembler for A64 -------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//
//===----------------------------------------------------------------------===//

#include "A64Disassembler.h"
#include "A64ExternalSymbolizer.h"
#include "MCTargetDesc/A64AddressingModes.h"
#include "MCTargetDesc/A64MCTargetDesc.h"
#include "TargetInfo/A64TargetInfo.h"
#include "llvm-c/Disassembler.h"
#include "llvm/MC/MCDecoderOps.h"
#include "llvm/MC/MCDisassembler/MCRelocationInfo.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/MC/TargetRegistry.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"

using namespace llvm;

#define DEBUG_TYPE "a64-disassembler"

// Pull DecodeStatus and its enum values into the global namespace.
using DecodeStatus = MCDisassembler::DecodeStatus;

// Forward declare these because the autogenerated code will reference them.
// Definitions are further down.
static DecodeStatus DecodeGPR64RegisterClass(MCInst &Inst, unsigned RegNo,
                                             uint64_t Addr,
                                             const void *Decoder);
static DecodeStatus DecodeGPR64spRegisterClass(MCInst &Inst, unsigned RegNo,
                                               uint64_t Address,
                                               const void *Decoder);
static DecodeStatus DecodeAddSubImmShift(MCInst &Inst, uint32_t insn,
                                         uint64_t Address, const void *Decoder);
static DecodeStatus DecodeLogicalImmInstruction(MCInst &Inst, uint32_t insn,
                                                uint64_t Address,
                                                const void *Decoder);
static DecodeStatus DecodeMoveImmInstruction(MCInst &Inst, uint32_t insn,
                                             uint64_t Address,
                                             const void *Decoder);
static DecodeStatus DecodePCRelLabel19(MCInst &Inst, unsigned Imm,
                                       uint64_t Address, const void *Decoder);
#include "A64GenDisassemblerTables.inc"
#include "A64GenInstrInfo.inc"

static const unsigned GPR64DecoderTable[] = {
    A64::X0,  A64::X1,  A64::X2,  A64::X3,  A64::X4,  A64::X5,  A64::X6,
    A64::X7,  A64::X8,  A64::X9,  A64::X10, A64::X11, A64::X12, A64::X13,
    A64::X14, A64::X15, A64::X16, A64::X17, A64::X18, A64::X19, A64::X20,
    A64::X21, A64::X22, A64::X23, A64::X24, A64::X25, A64::X26, A64::X27,
    A64::X28, A64::FP,  A64::LR,  A64::XZR};

static DecodeStatus DecodeGPR64RegisterClass(MCInst &Inst, unsigned RegNo,
                                             uint64_t Addr,
                                             const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;

  unsigned Register = GPR64DecoderTable[RegNo];
  Inst.addOperand(MCOperand::createReg(Register));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeGPR64spRegisterClass(MCInst &Inst, unsigned RegNo,
                                               uint64_t Addr,
                                               const void *Decoder) {
  if (RegNo > 31)
    return MCDisassembler::Fail;
  unsigned Register = GPR64DecoderTable[RegNo];
  if (Register == A64::XZR)
    Register = A64::SP;
  Inst.addOperand(MCOperand::createReg(Register));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeAddSubImmShift(MCInst &Inst, uint32_t insn,
                                         uint64_t Addr, const void *Decoder) {
  unsigned Rd = fieldFromInstruction(insn, 0, 5);
  unsigned Rn = fieldFromInstruction(insn, 5, 5);
  unsigned Imm = fieldFromInstruction(insn, 10, 14);
  unsigned S = fieldFromInstruction(insn, 29, 1);
  unsigned Datasize = fieldFromInstruction(insn, 31, 1);
  // We only support X registers.
  assert(Datasize == 1);
  unsigned ShifterVal = (Imm >> 12) & 3;
  unsigned ImmVal = Imm & 0xFFF;
  const A64Disassembler *Dis = static_cast<const A64Disassembler *>(Decoder);

  if (ShifterVal != 0 && ShifterVal != 1)
    return MCDisassembler::Fail;

  if (Datasize) {
    if (Rd == 31 && !S)
      DecodeGPR64spRegisterClass(Inst, Rd, Addr, Decoder);
    else
      DecodeGPR64RegisterClass(Inst, Rd, Addr, Decoder);
    DecodeGPR64spRegisterClass(Inst, Rn, Addr, Decoder);
  }

  if (!Dis->tryAddingSymbolicOperand(Inst, Imm, Addr, MCDisassembler::Fail, 0,
                                     0, 4))
    Inst.addOperand(MCOperand::createImm(ImmVal));
  Inst.addOperand(MCOperand::createImm(12 * ShifterVal));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeLogicalImmInstruction(MCInst &Inst, uint32_t insn,
                                                uint64_t Addr,
                                                const void *Decoder) {
  unsigned Rd = fieldFromInstruction(insn, 0, 5);
  unsigned Rn = fieldFromInstruction(insn, 5, 5);
  unsigned imm;

  if (Inst.getOpcode() == A64::ANDSXri)
    DecodeGPR64RegisterClass(Inst, Rd, Addr, Decoder);
  else
    DecodeGPR64spRegisterClass(Inst, Rd, Addr, Decoder);
  DecodeGPR64RegisterClass(Inst, Rn, Addr, Decoder);
  imm = fieldFromInstruction(insn, 10, 13);
  if (!A64_AM::isValidDecodeLogicalImmediate(imm, 64))
    return MCDisassembler::Fail;
  Inst.addOperand(MCOperand::createImm(imm));
  return MCDisassembler::Success;
}

static DecodeStatus DecodeMoveImmInstruction(MCInst &Inst, uint32_t insn,
                                             uint64_t Addr,
                                             const void *Decoder) {
  unsigned Rd = fieldFromInstruction(insn, 0, 5);
  unsigned imm = fieldFromInstruction(insn, 5, 16);
  unsigned shift = fieldFromInstruction(insn, 21, 2);
  shift <<= 4;
  switch (Inst.getOpcode()) {
  default:
    return MCDisassembler::Fail;
  case A64::MOVZ:
  case A64::MOVN:
  case A64::MOVK:
    DecodeGPR64RegisterClass(Inst, Rd, Addr, Decoder);
    break;
  }

  if (Inst.getOpcode() == A64::MOVK)
    Inst.addOperand(Inst.getOperand(0));

  Inst.addOperand(MCOperand::createImm(imm));
  Inst.addOperand(MCOperand::createImm(shift));
  return MCDisassembler::Success;
}

static DecodeStatus DecodePCRelLabel19(MCInst &Inst, unsigned Imm,
                                       uint64_t Addr, const void *Decoder) {
  int64_t ImmVal = Imm;
  const A64Disassembler *Dis = static_cast<const A64Disassembler *>(Decoder);

  // Sign-extend 19-bit immediate.
  if (ImmVal & (1 << (19 - 1)))
    ImmVal |= ~((1LL << 19) - 1);

  if (!Dis->tryAddingSymbolicOperand(Inst, ImmVal * 4, Addr,
                                     Inst.getOpcode() != A64::LDRXl, 0, 0, 4))
    Inst.addOperand(MCOperand::createImm(ImmVal));
  return MCDisassembler::Success;
}

static MCDisassembler *createA64Disassembler(const Target &T,
                                             const MCSubtargetInfo &STI,
                                             MCContext &Ctx) {
  return new A64Disassembler(STI, Ctx);
}

DecodeStatus A64Disassembler::getInstruction(MCInst &MI, uint64_t &Size,
                                             ArrayRef<uint8_t> Bytes,
                                             uint64_t Address,
                                             raw_ostream &CS) const {
  CommentStream = &CS;

  Size = 0;
  // We want to read exactly 4 bytes of data.
  if (Bytes.size() < 4)
    return MCDisassembler::Fail;
  Size = 4;

  // Encoded as a small-endian 32-bit word in the stream.
  uint32_t Insn =
      (Bytes[3] << 24) | (Bytes[2] << 16) | (Bytes[1] << 8) | (Bytes[0] << 0);

  // Calling the auto-generated decoder function.
  return decodeInstruction(DecoderTable32, MI, Insn, Address, this, STI);
}

static MCSymbolizer *
createA64ExternalSymbolizer(const Triple &TT, LLVMOpInfoCallback GetOpInfo,
                            LLVMSymbolLookupCallback SymbolLookUp,
                            void *DisInfo, MCContext *Ctx,
                            std::unique_ptr<MCRelocationInfo> &&RelInfo) {
  return new A64ExternalSymbolizer(*Ctx, std::move(RelInfo), GetOpInfo,
                                   SymbolLookUp, DisInfo);
}

extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeA64Disassembler() {
  TargetRegistry::RegisterMCDisassembler(getTheA64Target(),
                                         createA64Disassembler);
  TargetRegistry::RegisterMCSymbolizer(getTheA64Target(),
                                       createA64ExternalSymbolizer);
}
#define DEBUG_TYPE "a64-disassembler"
